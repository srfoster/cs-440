id: "m2-8queens-objective"
type: "short-answer"
chapter: 1
question: |
  **Formulate the 8-Queens problem as an optimization problem and implement the CONFLICTS objective function.**

  **Level 0** Discuss the difference between path-finding search and optimization-based search. Why is local search appropriate for problems like N-Queens?  Why are optimization problems important (in AI and beyond)?  

  **Level 1** Describe the 8-Queens problem as an optimization problem with an appropriate objective function.  Demonstrate a few iterations of a local search algorithm (e.g., hill climbing) on a sample board, showing how the objective function changes.

  **Level 2** Implement a solution to 8-Queens in a language of your choice. 

  **Level 3** Analyze the time complexity of this solution.  Discuss how the objective function landscape affects search: are there many local optima? How does the number of global optima (92 for 8-Queens with symmetries) relate to search difficulty?
answer: |
  **Level 0: Path-finding vs. Optimization-based Search**

  Path-finding search (like A*, BFS, DFS) explores a state space to find a sequence of actions from a start state to a goal state. The focus is on the path itself—each step represents a decision, and the solution is the sequence of steps taken.

  Optimization-based search (like local search, hill climbing) navigates through the space of complete candidate solutions, iteratively improving a solution based on an objective function. The focus is on the quality of the current complete state, not the path to reach it.

  Local search is appropriate for N-Queens because:
  - **Complete solutions**: We can start with any board configuration (one queen per column)
  - **Large state space**: 8^8 = 16.7 million possible configurations make systematic search expensive
  - **No path needed**: We only care about the final placement, not how we got there
  - **Good neighborhoods**: Small changes (moving one queen) can improve the solution

  Trade-offs:
  - ✓ Memory efficient (only stores current state, not search tree)
  - ✓ Fast for finding "good enough" solutions
  - ✗ Not guaranteed to find optimal solution (can get stuck in local optima)
  - ✗ No path information (can't trace how solution was reached)

  ---

  **Level 1: 8-Queens as an Optimization Problem**

  **Objective:** Minimize the number of conflicts (pairs of queens attacking each other)

  **State representation:** board[col] = row (one queen per column)

  **Objective function:** CONFLICTS(board) = number of queen pairs that attack each other

  **Goal state:** CONFLICTS(board) = 0

  **Example hill climbing iteration:**

  ```
  Initial board (random):
  Q . . . . . . .   CONFLICTS = 5
  . . . Q . . . .   (Queens at columns 0,3 conflict on diagonal;
  . . . . . . Q .   Queens at columns 1,7 conflict on diagonal, etc.)
  . Q . . . . . .
  . . . . . Q . .
  . . . . . . . Q
  . . Q . . . . .
  . . . . Q . . .

  Step 1: Try moving queen in column 2 from row 6 to row 5
  Effect: Reduces conflicts from 5 to 3
  Accept move ✓

  Step 2: Try moving queen in column 0 from row 0 to row 2
  Effect: Reduces conflicts from 3 to 2
  Accept move ✓

  Step 3: Try all moves in column 4, all increase conflicts
  Stuck in local optimum ✗
  ```

  ---

  **Level 2: Implementation**

  ```python
  def conflicts(board):
      """Count pairs of queens that attack each other."""
      n = len(board)
      count = 0
      for i in range(n):
          for j in range(i+1, n):
              # Same row conflict
              if board[i] == board[j]:
                  count += 1
              # Diagonal conflict
              elif abs(board[i] - board[j]) == abs(i - j):
                  count += 1
      return count

  def hill_climbing_8queens(max_iterations=1000):
      """Solve 8-Queens using hill climbing."""
      import random
      
      # Start with random configuration
      board = [random.randint(0, 7) for _ in range(8)]
      
      for iteration in range(max_iterations):
          current_conflicts = conflicts(board)
          
          # Goal reached
          if current_conflicts == 0:
              return board, iteration
          
          # Find best neighbor
          best_board = board[:]
          best_conflicts = current_conflicts
          
          for col in range(8):
              original_row = board[col]
              for row in range(8):
                  if row != original_row:
                      board[col] = row
                      new_conflicts = conflicts(board)
                      if new_conflicts < best_conflicts:
                          best_board = board[:]
                          best_conflicts = new_conflicts
              board[col] = original_row  # Restore
          
          # If no improvement, stuck in local optimum
          if best_conflicts >= current_conflicts:
              return None, iteration  # Failed
          
          board = best_board
      
      return None, max_iterations  # Timeout
  ```

  ---

  **Level 3: Complexity Analysis**

  **Time Complexity of CONFLICTS:**
  - Nested loops: O(n²) comparisons for n queens
  - For 8-Queens: O(1) constant time (fixed at 28 comparisons)

  **Time Complexity of Hill Climbing per iteration:**
  - Try moving each of 8 queens to 7 other positions = 56 neighbors
  - Evaluate CONFLICTS for each: 56 × O(n²) = O(n³) per iteration
  - For 8-Queens: O(1) per iteration (constant board size)

  **Objective Function Landscape:**
  - **Local optima**: Many! ~86% of random restarts get stuck in local optima with 1-3 conflicts
  - **Global optima**: 92 solutions (12 fundamental solutions × 8 symmetries from rotations/reflections)
  - **Plateau regions**: Many states with same conflict count
  - **Search difficulty**: High due to numerous local optima

  **Success rates:**
  - Basic hill climbing: ~14% success rate
  - Random restart hill climbing: ~100% success (average 6-7 restarts)
  - Simulated annealing: ~95% success (can escape local optima)

  The relatively high number of global optima (92) actually doesn't make search easier because they're scattered among far more local optima. The ratio of local:global optima determines difficulty more than absolute numbers.
topics:
  - "N-Queens"
  - "Objective Functions"
  - "Optimization"
example_videos:
  - "https://www.youtube.com/watch?v=xouin83ebxE"
