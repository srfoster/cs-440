id: "m1-bfs-iddfs"
type: "short-answer"
chapter: 1
question: |
  Many AI problems can be framed as state-space search, where we explore a graph whose nodes are states and whose edges are actions. Breadth-first search (BFS) explores states in increasing order of depth from the start; it is complete (will find a solution if one exists) and optimal for equal step costs, but often uses large memory. Iterative deepening depth-first search (IDDFS) combines the low memory footprint of DFS with the completeness/optimality (in unit-cost settings) of BFS by repeatedly running depth-limited DFS with increasing depth limits. These matter because they are foundational "default tools" and because the tradeoffs (time vs memory, optimality vs practicality) appear across all of AI.
  
  **Task:** Given the standard search interface ACTIONS(s), RESULT(s,a), GOAL_TEST(s), write pseudocode for BFS(start) and IDDFS(start, maxDepth). Your BFS should avoid revisiting states; your IDDFS should show a depth loop and a depth-limited search helper.
answer: "BFS uses a queue (FIFO) to explore states level by level, guaranteeing the shortest path but requiring O(b^d) space. IDDFS performs repeated depth-limited searches with increasing depth limits, achieving BFS's completeness and optimality with only O(bd) space. IDDFS is preferred when memory is limited and the branching factor is high, even though it revisits states."
answer_kindergarten: "Imagine finding your way through a maze. BFS is like bringing lots of friends to explore every path at the same time, level by level - you'll find the shortest way out but need lots of friends to remember everything. IDDFS is like going in yourself, trying paths that go just 1 step deep, then 2 steps, then 3 steps, and so on. You might check some paths twice, but you don't need to remember as much!"
answer_3rd_grade: "BFS explores all possible moves one step away, then two steps away, then three steps, and so on, until it finds the goal. It uses a line (queue) to keep track of what to explore next. It finds the shortest path but needs lots of memory. IDDFS is smarter with memory - it searches up to depth 1, then restarts and searches up to depth 2, then depth 3, and keeps going until it finds the answer."
answer_7th_grade: "BFS maintains a queue of states to explore. It adds the start state, then repeatedly takes the front state from the queue, generates all its children using ACTIONS and RESULT, and adds unvisited children to the back of the queue. When it finds the goal, it reconstructs the path using parent pointers. IDDFS runs depth-limited search repeatedly with limits 0, 1, 2, 3... until finding the goal. Each depth-limited search uses recursion and a limit parameter, returning failure if the limit is reached without finding the goal."
answer_high_school: "BFS is a complete, optimal graph search algorithm for uniform-cost problems. Implementation uses a FIFO queue for the frontier, a visited set to prevent cycles, and a parent map for path reconstruction. When a goal is found, backtracking through parent pointers yields the solution path. IDDFS iteratively performs depth-limited search (DLS) with increasing depth limits. DLS uses recursion with a depth parameter, returning failure if depth reaches 0 before finding a goal. IDDFS combines DFS's space efficiency O(bd) with BFS's optimality for uniform costs."
answer_undergraduate: "BFS: Complete and optimal for unit-cost edges. Time O(b^d), space O(b^d) where b is branching factor and d is solution depth. Space complexity is the limiting factor for large problems. IDDFS: Iteratively executes DLS with depth cutoffs 0,1,2,...,d. Time complexity O(b^d) - appears wasteful with repeated state generation, but for trees with branching factor b>1, overhead is actually O(b^(d-1) + b^(d-2) + ...) = O(b^d / (b-1)), asymptotically similar to BFS. Space complexity O(bd) is dramatically better, making IDDFS preferred for large state spaces with reasonable branching factors. Key insight: in exponential growth, the last level dominates, so revisiting earlier levels is acceptable. IDDFS is optimal for uniform-cost problems and complete for infinite state spaces where BFS would exhaust memory."
topics:
  - "Search Algorithms"
  - "BFS"
  - "IDDFS"
  - "Completeness and Optimality"
vocab_answer:
  - word: "queue"
    definition: "A first-in-first-out (FIFO) data structure"
  - word: "frontier"
    definition: "The set of states that have been generated but not yet explored"
  - word: "depth-limited"
    definition: "A search that stops exploring paths that exceed a specified depth"
vocab_kindergarten:
  - word: "level"
    definition: "How many steps away something is from where you started"
  - word: "remember"
    definition: "To keep information about what you've already seen"
vocab_3rd_grade:
  - word: "queue"
    definition: "A waiting line where the first person in is the first person out"
  - word: "restart"
    definition: "To go back to the beginning and start over"
vocab_7th_grade:
  - word: "recursion"
    definition: "When a function calls itself to solve smaller versions of a problem"
  - word: "parent pointer"
    definition: "A reference to the previous state that led to the current state"
vocab_high_school:
  - word: "FIFO"
    definition: "First In, First Out - a queue discipline"
  - word: "backtracking"
    definition: "Retracing steps from goal to start using stored parent information"
vocab_undergraduate:
  - word: "branching factor"
    definition: "Average number of successors per state"
  - word: "asymptotic complexity"
    definition: "Behavior of an algorithm as input size approaches infinity"
example_videos:
  - "https://www.youtube.com/watch?v=oDqjPvD54Ss"
  - "https://www.youtube.com/watch?v=NUgMa5coCoE"
