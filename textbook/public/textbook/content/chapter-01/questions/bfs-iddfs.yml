id: "m1-bfs-iddfs-dls"
type: "short-answer"
chapter: 1
question: |
  Many AI problems can be framed as state-space search, where we explore a graph whose nodes are states and whose edges are actions. Breadth-first search (BFS) explores states in increasing order of depth from the start; it is complete (will find a solution if one exists) and optimal for equal step costs, but often uses large memory. Depth-limited search (DLS) is a variant of DFS that explores paths only up to a maximum depthâ€”useful when deeper search becomes too expensive or as a building block for other algorithms. Iterative deepening depth-first search (IDDFS) combines the low memory footprint of DFS with the completeness/optimality of BFS by repeatedly running DLS with increasing depth limits. These matter because they are foundational "default tools" and because the tradeoffs (time vs memory, optimality vs practicality) appear across all of AI. Real AI systems often cannot afford unlimited search; they must manage computation using resource bounds while still behaving sensibly.
  
  **Task:** Using the 8-puzzle problem formulation (with ACTIONS, RESULT, and GOAL_TEST from the previous question), write pseudocode for three search algorithms: (1) BFS(start) that avoids revisiting states, (2) DLS(start, limit, parent) that performs depth-limited search and stops expanding beyond the depth limit, and (3) IDDFS(start, maxDepth) that calls DLS iteratively with increasing limits.
answer: "BFS uses a queue (FIFO) to explore states level by level, guaranteeing the shortest path but requiring O(b^d) space. DLS performs DFS but stops at a specified depth limit, returning failure if the goal isn't found within that depth. IDDFS performs repeated depth-limited searches with increasing depth limits (0, 1, 2, ...), achieving BFS's completeness and optimality with only O(bd) space. For the 8-puzzle, IDDFS is often preferred over BFS due to the large state space, even though it revisits some states."
answer_kindergarten: "Imagine solving a sliding tile puzzle. BFS is like bringing lots of friends to try every possible move at the same time, level by level - you'll find the shortest solution but need lots of friends to remember everything. DLS is like saying 'I'll only try 5 moves deep, then give up.' IDDFS is like trying 1 move deep, then starting over and trying 2 moves deep, then 3 moves, and so on. You might check some moves twice, but you don't need to remember as much!"
answer_3rd_grade: "For the 8-puzzle: BFS explores all possible tile moves one step away, then two steps away, then three steps, and so on. It uses a line (queue) to keep track. It finds the shortest solution but needs lots of memory. DLS says 'I'll only look 5 moves ahead' and gives up if it doesn't find the solution. IDDFS is smarter - it searches up to depth 1, then restarts and searches up to depth 2, then depth 3, and keeps going until it finds the solution."
answer_7th_grade: "For the 8-puzzle: BFS maintains a queue of board states to explore. It adds the start state, then repeatedly takes the front state, generates all possible tile moves using ACTIONS and RESULT, and adds unvisited states to the back. When it finds the goal configuration, it reconstructs the solution path using parent pointers. DLS uses recursion with a depth limit, returning failure if the limit is reached. IDDFS runs DLS repeatedly with limits 0, 1, 2, 3... until finding the goal. This finds the optimal solution like BFS but uses much less memory."
answer_high_school: "BFS is a complete, optimal graph search algorithm for uniform-cost problems. Implementation uses a FIFO queue for the frontier, a visited set to prevent cycles, and a parent map for path reconstruction. When a goal is found, backtracking through parent pointers yields the solution path. IDDFS iteratively performs depth-limited search (DLS) with increasing depth limits. DLS uses recursion with a depth parameter, returning failure if depth reaches 0 before finding a goal. IDDFS combines DFS's space efficiency O(bd) with BFS's optimality for uniform costs."
answer_undergraduate: "BFS: Complete and optimal for unit-cost edges. Time O(b^d), space O(b^d) where b is branching factor and d is solution depth. Space complexity is the limiting factor for large problems. IDDFS: Iteratively executes DLS with depth cutoffs 0,1,2,...,d. Time complexity O(b^d) - appears wasteful with repeated state generation, but for trees with branching factor b>1, overhead is actually O(b^(d-1) + b^(d-2) + ...) = O(b^d / (b-1)), asymptotically similar to BFS. Space complexity O(bd) is dramatically better, making IDDFS preferred for large state spaces with reasonable branching factors. Key insight: in exponential growth, the last level dominates, so revisiting earlier levels is acceptable. IDDFS is optimal for uniform-cost problems and complete for infinite state spaces where BFS would exhaust memory."
topics:
  - "Search Algorithms"
  - "BFS"
  - "Depth-Limited Search"
  - "IDDFS"
  - "Completeness and Optimality"
vocab_answer:
  - word: "queue"
    definition: "A first-in-first-out (FIFO) data structure"
  - word: "frontier"
    definition: "The set of states that have been generated but not yet explored"
  - word: "depth-limited"
    definition: "A search that stops exploring paths that exceed a specified depth"
vocab_kindergarten:
  - word: "level"
    definition: "How many steps away something is from where you started"
  - word: "remember"
    definition: "To keep information about what you've already seen"
vocab_3rd_grade:
  - word: "queue"
    definition: "A waiting line where the first person in is the first person out"
  - word: "restart"
    definition: "To go back to the beginning and start over"
vocab_7th_grade:
  - word: "recursion"
    definition: "When a function calls itself to solve smaller versions of a problem"
  - word: "parent pointer"
    definition: "A reference to the previous state that led to the current state"
vocab_high_school:
  - word: "FIFO"
    definition: "First In, First Out - a queue discipline"
  - word: "backtracking"
    definition: "Retracing steps from goal to start using stored parent information"
vocab_undergraduate:
  - word: "branching factor"
    definition: "Average number of successors per state"
  - word: "asymptotic complexity"
    definition: "Behavior of an algorithm as input size approaches infinity"
example_videos:
  - "https://www.youtube.com/watch?v=oDqjPvD54Ss"
  - "https://www.youtube.com/watch?v=NUgMa5coCoE"
