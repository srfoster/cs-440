id: "m1-bfs-iddfs"
type: "short-answer"
chapter: 1
question: |
  **Implement BFS (Breadth-First Search) and IDDFS (Iterative Deepening Depth-First Search) algorithms.**
  
  **Level 0** Discuss why we need different search strategies. What are the trade-offs between memory usage and completeness?
  
  **Level 1** Explain how BFS explores states level by level using a queue, and how IDDFS combines the benefits of BFS and DFS by repeatedly performing depth-limited searches with increasing depth limits. Provide pseudocode for both algorithms.
  
  **Level 2** Implement BFS and IDDFS for a generic state space using ACTIONS, RESULT, and GOAL_TEST functions. Include path reconstruction.
  
  **Level 3** Analyze the time and space complexity of both algorithms. Compare their performance characteristics: when is IDDFS preferred over BFS despite exploring some states multiple times?
answer: "BFS uses a queue (FIFO) to explore states level by level, guaranteeing the shortest path but requiring O(b^d) space. IDDFS performs repeated depth-limited searches with increasing depth limits, achieving BFS's completeness and optimality with only O(bd) space. IDDFS is preferred when memory is limited and the branching factor is high, even though it revisits states."
answer_kindergarten: "Imagine finding your way through a maze. BFS is like bringing lots of friends to explore every path at the same time, level by level - you'll find the shortest way out but need lots of friends to remember everything. IDDFS is like going in yourself, trying paths that go just 1 step deep, then 2 steps, then 3 steps, and so on. You might check some paths twice, but you don't need to remember as much!"
answer_3rd_grade: "BFS explores all possible moves one step away, then two steps away, then three steps, and so on, until it finds the goal. It uses a line (queue) to keep track of what to explore next. It finds the shortest path but needs lots of memory. IDDFS is smarter with memory - it searches up to depth 1, then restarts and searches up to depth 2, then depth 3, and keeps going until it finds the answer."
answer_7th_grade: "BFS maintains a queue of states to explore. It adds the start state, then repeatedly takes the front state from the queue, generates all its children using ACTIONS and RESULT, and adds unvisited children to the back of the queue. When it finds the goal, it reconstructs the path using parent pointers. IDDFS runs depth-limited search repeatedly with limits 0, 1, 2, 3... until finding the goal. Each depth-limited search uses recursion and a limit parameter, returning failure if the limit is reached without finding the goal."
answer_high_school: "BFS is a complete, optimal graph search algorithm for uniform-cost problems. Implementation uses a FIFO queue for the frontier, a visited set to prevent cycles, and a parent map for path reconstruction. When a goal is found, backtracking through parent pointers yields the solution path. IDDFS iteratively performs depth-limited search (DLS) with increasing depth limits. DLS uses recursion with a depth parameter, returning failure if depth reaches 0 before finding a goal. IDDFS combines DFS's space efficiency O(bd) with BFS's optimality for uniform costs."
answer_undergraduate: "BFS: Complete and optimal for unit-cost edges. Time O(b^d), space O(b^d) where b is branching factor and d is solution depth. Space complexity is the limiting factor for large problems. IDDFS: Iteratively executes DLS with depth cutoffs 0,1,2,...,d. Time complexity O(b^d) - appears wasteful with repeated state generation, but for trees with branching factor b>1, overhead is actually O(b^(d-1) + b^(d-2) + ...) = O(b^d / (b-1)), asymptotically similar to BFS. Space complexity O(bd) is dramatically better, making IDDFS preferred for large state spaces with reasonable branching factors. Key insight: in exponential growth, the last level dominates, so revisiting earlier levels is acceptable. IDDFS is optimal for uniform-cost problems and complete for infinite state spaces where BFS would exhaust memory."
topics:
  - "Search Algorithms"
  - "BFS"
  - "IDDFS"
  - "Completeness and Optimality"
vocab_answer:
  - word: "queue"
    definition: "A first-in-first-out (FIFO) data structure"
  - word: "frontier"
    definition: "The set of states that have been generated but not yet explored"
  - word: "depth-limited"
    definition: "A search that stops exploring paths that exceed a specified depth"
vocab_kindergarten:
  - word: "level"
    definition: "How many steps away something is from where you started"
  - word: "remember"
    definition: "To keep information about what you've already seen"
vocab_3rd_grade:
  - word: "queue"
    definition: "A waiting line where the first person in is the first person out"
  - word: "restart"
    definition: "To go back to the beginning and start over"
vocab_7th_grade:
  - word: "recursion"
    definition: "When a function calls itself to solve smaller versions of a problem"
  - word: "parent pointer"
    definition: "A reference to the previous state that led to the current state"
vocab_high_school:
  - word: "FIFO"
    definition: "First In, First Out - a queue discipline"
  - word: "backtracking"
    definition: "Retracing steps from goal to start using stored parent information"
vocab_undergraduate:
  - word: "branching factor"
    definition: "Average number of successors per state"
  - word: "asymptotic complexity"
    definition: "Behavior of an algorithm as input size approaches infinity"
example_videos:
  - "https://www.youtube.com/watch?v=oDqjPvD54Ss"
  - "https://www.youtube.com/watch?v=NUgMa5coCoE"
