id: "m4-csp-fundamentals"
type: "short-answer"
chapter: 2
question: |
  **Solve Sudoku using backtracking search with forward checking.**

  **Level 0** Discuss how Sudoku differs from 8-puzzle. In 8-puzzle, we search for a sequence of actions (path). In Sudoku, we search for an assignment of values to variables satisfying constraints. No "path cost," no "neighbors"—just: does this assignment satisfy all rules? Compare: 8-puzzle used A* with Manhattan distance; Sudoku uses backtracking with constraint propagation. Both exploit structure, but different kinds.

  **Level 1** Formulate Sudoku as a CSP. Variables: 81 cells C₀₀ through C₈₈ (row, column notation). Domains: Dᵢⱼ = {1,...,9} for empty cells, Dᵢⱼ = {given clue} for filled cells. Constraints: (1) AllDifferent(row i), (2) AllDifferent(column j), (3) AllDifferent(box b) for 9 boxes. Give pseudocode for MAKE_SUDOKU_CSP(initialGrid) that builds variable list, domain map, and neighbor lists (cells in same row/col/box).
  
  Describe backtracking: choose unassigned cell, try values 1-9, check if assignment violates constraints (duplicate in row/col/box), recurse. If all cells assigned, return solution. If dead end, backtrack. Give pseudocode for BACKTRACK_SUDOKU(assignment, csp).
  
  Now add forward checking: after assigning cell C=v, remove v from domains of all neighbors (same row/col/box). If any neighbor's domain becomes empty, backtrack immediately—no need to try further assignments. Give pseudocode for BACKTRACK_FC(assignment, csp, domains). Demonstrate by hand: 4×4 Sudoku (4 rows, 4 cols, four 2×2 boxes, digits 1-4) with 8 clues given. Show how forward checking prunes.

  **Level 2** Implement Sudoku solver with backtracking and forward checking. Test on easy/medium/hard puzzles. Compare nodes expanded: backtracking alone vs. with forward checking (should be 10-100× fewer). Implement MRV (minimum remaining values) heuristic: choose cell with fewest legal values left. Why does this help? It fails first on impossible branches. Implement LCV (least-constraining-value): try values that remove fewest options from neighbors. Test: does MRV+LCV improve performance?

  **Level 3** Analyze Sudoku complexity. Naive backtracking: O(9^n) where n=number of empty cells (worst case ≈81). With forward checking and MRV: much faster in practice, but still exponential worst-case. Prove forward checking correctness: removing values that can't participate in any solution doesn't eliminate solutions. Discuss when Sudoku is easy: if constraint propagation solves it without backtracking ("logic-solvable"). When is Sudoku hard? When you need deep search despite heavy pruning. Compare with other CSPs: graph coloring (NP-complete, like Sudoku), scheduling (similar techniques), vs. 2-SAT (P-time). Why does structure matter so much?  How does arc consistency (AC-3) differ from forward checking? AC-3 enforces consistency across all arcs, not just immediate neighbors, further reducing domains before search. Implement AC-3 and compare performance on hard puzzles.
  How does cutset conditioning work? Identify a small set of variables (cutset) that, when assigned, breaks the problem into independent subproblems. Solve each subproblem separately. This can reduce complexity from exponential in n to exponential in the size of the cutset, which is often much smaller.

answer: "CSP consists of variables (X₁,...,Xₙ), domains (D₁,...,Dₙ), and constraints limiting value combinations. Backtracking assigns variables sequentially, checking consistency. Forward checking prunes neighbor domains after each assignment, detecting failures early. When any domain becomes empty, backtrack. Heuristics: MRV (pick variable with fewest legal values), degree (most constraints), LCV (value constraining fewest neighbors). Complexity: O(d^n) worst-case, much faster with inference and heuristics."
topics:
  - "CSP"
  - "Backtracking"
  - "Forward Checking"
  - "Map Coloring"
  - "MRV Heuristic"
vocab_answer:
  - word: "domain"
    definition: "The set of possible values for a variable"
  - word: "constraint"
    definition: "A restriction on which combinations of values are allowed"
  - word: "forward checking"
    definition: "Pruning neighbor domains after variable assignment"
example_videos:
  - "https://www.youtube.com/watch?v=hJ-6Ma1veUE"
