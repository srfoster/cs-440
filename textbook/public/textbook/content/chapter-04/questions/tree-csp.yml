id: "m4-tree-csp"
type: "short-answer"
chapter: 4
question: |
  The difficulty of CSP solving depends heavily on the structure of the constraint graph. If the constraint graph is a tree (acyclic), the CSP can be solved in time linear in the number of variables (up to domain factors) using dynamic programming: first enforce consistency from leaves to root, then assign values from root to leaves. This matters because it shows that "NP-hard in general" can become "easy" under structural restrictions, motivating concepts like treewidth.
  
  **Task:** Write pseudocode for TREE_CSP_SOLVE(csp, root) that solves a tree-structured CSP efficiently.
answer: |
  Tree-structured CSPs can be solved in linear time by making the CSP arc-consistent from leaves to root, then assigning values from root to leaves ensuring consistency with parent assignments.
  
  Pseudocode:
  ```
  function TREE_CSP_SOLVE(csp, root):
      order = TOPOLOGICAL_ORDER_FROM_ROOT(csp, root)
      parent = PARENTS_FROM_ROOT(csp, root)
      
      # make arc-consistent from leaves upward
      for X in reverse(order):
          for Y in csp.neigh[X]:
              if parent[X] == Y:
                  REVISE(csp, Y, X)
      
      assignment = {}
      assignment[root] = any value in csp.dom[root]
      for X in order:
          if X == root: continue
          P = parent[X]
          assignment[X] = any v in csp.dom[X] with CONSTRAINT_OK(P, assignment[P], X, v)
      return assignment
  ```
topics:
  - "Tree-Structured CSP"
  - "Dynamic Programming"
  - "Arc Consistency"
example_videos:
  - "https://www.youtube.com/watch?v=hJ-6Ma1veUE"
