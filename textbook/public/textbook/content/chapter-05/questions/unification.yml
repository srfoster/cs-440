id: "m5-unification"
type: "short-answer"
chapter: 5
question: |
  In first-order logic, unification is the process of finding a substitution for variables that makes two logical expressions identical. It is fundamental to resolution, theorem proving, and logic programming (e.g., Prolog). This matters because unification is the "mechanical heart" of symbolic reasoning: it's how a system matches patterns and applies general rules to specific situations.
  
  **Task:** Write pseudocode for UNIFY(x, y, subst) including variable handling and occurs-check.
  
  **Level 2** Implement UNIFY(x, y, subst) with occurs check to prevent infinite structures.
  
  **Level 3** Discuss unification's role in resolution, Prolog, and type inference. Analyze time complexity and most general unifiers (MGU).
answer: "Unification finds substitutions θ such that SUBST(θ, x) = SUBST(θ, y). Algorithm recursively processes terms: if both are identical, success; if one is a variable, extend substitution; if both are functions with same name/arity, unify arguments pairwise. Occurs check prevents X from unifying with f(X). Returns most general unifier or failure."
topics:
  - "Unification"
  - "First-Order Logic"
  - "Pattern Matching"
vocab_answer:
  - word: "substitution"
    definition: "A mapping from variables to terms"
  - word: "occurs check"
    definition: "Test preventing a variable from unifying with a term containing itself"
example_videos:
  - "https://www.youtube.com/watch?v=vXqUZNpPJ8Y"
